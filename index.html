<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1080, height=1080, initial-scale=1.0, user-scalable=no">
    <title>Tech Convention Interactive Host</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            width: 1080px;
            height: 1080px;
            overflow: hidden;
            background: #0a0e27;
            position: relative;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            cursor: none;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 1080px;
            height: 1080px;
            pointer-events: none;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .greeting-container {
            position: absolute;
            top: 140px;
            display: flex;
            flex-direction: column;
            align-items: center;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .greeting-container.active {
            opacity: 1;
            transform: translateY(0);
        }

        .greeting-text {
            color: #ffffff;
            font-size: 52px;
            font-weight: 300;
            letter-spacing: -1px;
            margin-bottom: 10px;
            text-align: center;
        }

        .greeting-subtext {
            color: #64d9ff;
            font-size: 24px;
            font-weight: 500;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .question-container {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: all 0.5s ease;
            pointer-events: auto;
            text-align: center;
            width: 85%;
        }

        .question-container.active {
            opacity: 1;
        }

        .question-text {
            color: #ffffff;
            font-size: 42px;
            font-weight: 200;
            margin-bottom: 50px;
            letter-spacing: 0.5px;
        }

        .options {
            display: flex;
            gap: 40px;
            justify-content: center;
        }

        .option-btn {
            padding: 25px 50px;
            background: linear-gradient(135deg, rgba(100, 217, 255, 0.1), rgba(100, 217, 255, 0.05));
            border: 2px solid #64d9ff;
            border-radius: 60px;
            color: #ffffff;
            font-size: 24px;
            font-weight: 400;
            letter-spacing: 0.5px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(10px);
            min-width: 200px;
        }

        .option-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(100, 217, 255, 0.3), transparent);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .option-btn:hover {
            transform: translateY(-3px);
            background: linear-gradient(135deg, rgba(100, 217, 255, 0.2), rgba(100, 217, 255, 0.1));
            box-shadow: 0 10px 40px rgba(100, 217, 255, 0.3);
        }

        .option-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .option-btn:active {
            transform: translateY(0);
        }

        .option-btn.positive {
            border-color: #4ade80;
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.1), rgba(74, 222, 128, 0.05));
        }

        .option-btn.positive:hover {
            background: linear-gradient(135deg, rgba(74, 222, 128, 0.2), rgba(74, 222, 128, 0.1));
            box-shadow: 0 10px 40px rgba(74, 222, 128, 0.3);
        }

        .message-display {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%) scale(0.95);
            background: linear-gradient(135deg, rgba(100, 217, 255, 0.05), rgba(100, 217, 255, 0.02));
            border: 1px solid rgba(100, 217, 255, 0.3);
            border-radius: 20px;
            padding: 35px 50px;
            opacity: 0;
            transition: all 0.5s ease;
            width: 80%;
            max-width: 700px;
            text-align: center;
            backdrop-filter: blur(20px);
        }

        .message-display.active {
            opacity: 1;
            transform: translateX(-50%) scale(1);
        }

        .message-text {
            color: #ffffff;
            font-size: 28px;
            font-weight: 300;
            line-height: 1.5;
            letter-spacing: 0.3px;
        }

        .message-text .highlight {
            color: #64d9ff;
            font-weight: 400;
        }

        .emoji {
            font-size: 36px;
            margin: 0 8px;
            display: inline-block;
            vertical-align: middle;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .grid-line {
            stroke: rgba(100, 217, 255, 0.1);
            stroke-width: 1;
            fill: none;
        }

        .hidden-exit {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            opacity: 0;
            cursor: pointer;
            z-index: 9999;
        }
    </style>
</head>
<body>
    <canvas id="canvas" width="1080" height="1080"></canvas>
    
    <!-- Hidden exit button for staff -->
    <div class="hidden-exit" onclick="window.close()"></div>
    
    <div class="ui-overlay">
        <div class="greeting-container" id="greetingContainer">
            <div class="greeting-text">Welcome</div>
            <div class="greeting-subtext">Tech Convention 2025</div>
        </div>
        
        <div class="question-container" id="questionContainer">
            <div class="question-text">How are you today?</div>
            <div class="options">
                <button class="option-btn positive" onclick="handleOption('good')">
                    Great! 
                </button>
                <button class="option-btn" onclick="handleOption('bad')">
                    Could be better
                </button>
            </div>
        </div>
        
        <div class="message-display" id="messageDisplay">
            <div class="message-text" id="messageText"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const centerX = 540;
        const centerY = 540;
        
        let time = 0;
        let particles = [];
        let connections = [];
        let aiState = 'idle';
        let pulseIntensity = 0;
        let activeState = false;
        
        // Initialize particle network
        for (let i = 0; i < 60; i++) {
            particles.push({
                x: Math.random() * 1080,
                y: Math.random() * 1080,
                vx: (Math.random() - 0.5) * 0.3,
                vy: (Math.random() - 0.5) * 0.3,
                radius: Math.random() * 2 + 1,
                pulse: Math.random() * Math.PI * 2
            });
        }

        function drawBackground() {
            // Dark gradient background
            const bgGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 600);
            bgGradient.addColorStop(0, '#0f1729');
            bgGradient.addColorStop(1, '#0a0e27');
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, 1080, 1080);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(100, 217, 255, 0.03)';
            ctx.lineWidth = 1;
            
            // Circular grid
            for (let r = 100; r < 540; r += 80) {
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Radial lines
            for (let a = 0; a < Math.PI * 2; a += Math.PI / 8) {
                ctx.beginPath();
                ctx.moveTo(centerX + Math.cos(a) * 100, centerY + Math.sin(a) * 100);
                ctx.lineTo(centerX + Math.cos(a) * 540, centerY + Math.sin(a) * 540);
                ctx.stroke();
            }
        }

        function drawParticleNetwork() {
            // Update particles
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.pulse += 0.02;
                
                // Bounce off edges
                if (p.x < 0 || p.x > 1080) p.vx *= -1;
                if (p.y < 0 || p.y > 1080) p.vy *= -1;
                
                // Keep within circle
                const dx = p.x - centerX;
                const dy = p.y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > 520) {
                    p.vx *= -1;
                    p.vy *= -1;
                }
            });
            
            // Draw connections
            ctx.strokeStyle = 'rgba(100, 217, 255, 0.2)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const dx = particles[i].x - particles[j].x;
                    const dy = particles[i].y - particles[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < 150) {
                        ctx.globalAlpha = (1 - dist / 150) * 0.5;
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
            
            ctx.globalAlpha = 1;
            
            // Draw particles
            particles.forEach(p => {
                const brightness = Math.sin(p.pulse) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(100, 217, 255, ${brightness * 0.8})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawAICore() {
            const breathe = Math.sin(time * 0.02) * 10;
            const rotation = time * 0.005;
            
            // Outer rings
            ctx.strokeStyle = 'rgba(100, 217, 255, 0.3)';
            ctx.lineWidth = 2;
            
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.translate(centerX, centerY - 30);
                ctx.rotate(rotation + i * Math.PI / 3);
                
                ctx.beginPath();
                ctx.arc(0, 0, 150 + i * 30 + breathe, 0, Math.PI * 2);
                ctx.stroke();
                
                // Arc segments
                for (let j = 0; j < 6; j++) {
                    ctx.beginPath();
                    ctx.arc(0, 0, 150 + i * 30 + breathe, 
                           j * Math.PI / 3, 
                           j * Math.PI / 3 + Math.PI / 6);
                    ctx.strokeStyle = `rgba(100, 217, 255, ${0.5 + Math.sin(time * 0.05 + j) * 0.3})`;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
            
            // Central core
            const coreGradient = ctx.createRadialGradient(
                centerX, centerY - 30, 0,
                centerX, centerY - 30, 100 + breathe
            );
            coreGradient.addColorStop(0, 'rgba(100, 217, 255, 0.8)');
            coreGradient.addColorStop(0.5, 'rgba(100, 217, 255, 0.3)');
            coreGradient.addColorStop(1, 'rgba(100, 217, 255, 0)');
            
            ctx.fillStyle = coreGradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY - 30, 100 + breathe, 0, Math.PI * 2);
            ctx.fill();
            
            // Inner core details
            if (activeState) {
                pulseIntensity = Math.min(pulseIntensity + 0.05, 1);
            } else {
                pulseIntensity = Math.max(pulseIntensity - 0.02, 0);
            }
            
            if (pulseIntensity > 0) {
                // Active state visualization
                ctx.strokeStyle = `rgba(100, 217, 255, ${pulseIntensity})`;
                ctx.lineWidth = 3;
                
                // Sound wave visualization
                for (let i = 0; i < 5; i++) {
                    const radius = 30 + i * 15;
                    const waveOffset = Math.sin(time * 0.1 - i * 0.5) * 10;
                    
                    ctx.beginPath();
                    for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
                        const r = radius + Math.sin(angle * 8 + time * 0.1) * waveOffset * pulseIntensity;
                        const x = centerX + Math.cos(angle) * r;
                        const y = centerY - 30 + Math.sin(angle) * r;
                        
                        if (angle === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }
            
            // Eye-like sensors
            const eyeY = centerY - 30;
            const eyeSpacing = 40;
            
            [-1, 1].forEach(side => {
                const eyeX = centerX + side * eyeSpacing;
                
                // Outer ring
                ctx.strokeStyle = 'rgba(100, 217, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, 15, 0, Math.PI * 2);
                ctx.stroke();
                
                // Inner dot
                const blinkFactor = Math.sin(time * 0.03 + side) * 0.5 + 0.5;
                ctx.fillStyle = `rgba(100, 217, 255, ${0.5 + blinkFactor * 0.5})`;
                ctx.beginPath();
                ctx.arc(eyeX, eyeY, 5, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function animate() {
            time++;
            
            // Clear and draw
            drawBackground();
            drawParticleNetwork();
            drawAICore();
            
            requestAnimationFrame(animate);
        }

        function triggerGreeting() {
            aiState = 'greeting';
            activeState = true;
            
            // Show greeting
            document.getElementById('greetingContainer').classList.add('active');
            
            setTimeout(() => {
                document.getElementById('greetingContainer').classList.remove('active');
                // Show question after greeting
                setTimeout(() => {
                    document.getElementById('questionContainer').classList.add('active');
                    activeState = false;
                }, 500);
            }, 2500);
        }

        function handleOption(choice) {
            activeState = true;
            // Hide question
            document.getElementById('questionContainer').classList.remove('active');
            
            const messageDisplay = document.getElementById('messageDisplay');
            const messageText = document.getElementById('messageText');
            
            if (choice === 'good') {
                // First message
                messageText.innerHTML = `Excellent! Our team has prepared <span class="highlight">cutting-edge demos</span> just for you.`;
                messageDisplay.classList.add('active');
                
                // Second message after delay
                setTimeout(() => {
                    messageText.innerHTML = `Grab a <span class="highlight">chocolate</span> and <span class="highlight">info packet</span> at our booth! <span class="emoji">ðŸš€</span>`;
                }, 3500);
                
            } else {
                // First message
                messageText.innerHTML = `We understand. Tech can be overwhelming sometimes.`;
                messageDisplay.classList.add('active');
                
                // Second message after delay
                setTimeout(() => {
                    messageText.innerHTML = `Take <span class="highlight">two chocolates</span> - they're debug-tested for happiness! <span class="emoji">ðŸ’™</span>`;
                }, 3500);
            }
            
            // Reset after 7 seconds
            setTimeout(() => {
                messageDisplay.classList.remove('active');
                document.getElementById('questionContainer').classList.remove('active');
                activeState = false;
                
                // Ready for next visitor
                setTimeout(() => {
                    triggerGreeting();
                }, 3000);
            }, 7000);
        }

        // Start animation
        animate();
        
        // Auto-trigger greeting after 1.5 seconds
        setTimeout(triggerGreeting, 1500);
        
        // Touch/click to trigger (for testing)
        document.addEventListener('click', (e) => {
            if (!e.target.classList.contains('option-btn') && 
                !e.target.classList.contains('hidden-exit') && 
                aiState !== 'greeting') {
                triggerGreeting();
            }
        });

        // Prevent getting stuck - auto-reset if idle too long
        let idleTimer;
        function resetIdleTimer() {
            clearTimeout(idleTimer);
            idleTimer = setTimeout(() => {
                // Force reset if stuck
                document.getElementById('greetingContainer').classList.remove('active');
                document.getElementById('questionContainer').classList.remove('active');
                document.getElementById('messageDisplay').classList.remove('active');
                activeState = false;
                aiState = 'idle';
                setTimeout(triggerGreeting, 1000);
            }, 30000); // Reset after 30 seconds of inactivity
        }
        
        document.addEventListener('click', resetIdleTimer);
        resetIdleTimer();

        // For Raspberry Pi sensor integration
        /*
        setInterval(() => {
            fetch('/api/check-sensor')
                .then(res => res.json())
                .then(data => {
                    if (data.personDetected && aiState === 'idle') {
                        triggerGreeting();
                    }
                })
                .catch(err => console.log('Sensor check failed:', err));
        }, 1000);
        */
    </script>
</body>
</html>